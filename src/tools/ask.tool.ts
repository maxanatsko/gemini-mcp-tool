import { z } from 'zod';
import { UnifiedTool } from './registry.js';
import { getBackend, BackendType } from '../backends/index.js';
import { processChangeModeOutput } from '../utils/geminiExecutor.js';
import {
  ERROR_MESSAGES,
  CODEX_MODELS,
  MODELS
} from '../constants.js';
import { askSessionManager } from '../utils/askSessionManager.js';
import { extractFilesFromPrompt } from '../utils/reviewPromptBuilder.js';
import { Logger } from '../utils/logger.js';

const askArgsSchema = z.object({
  prompt: z.string().min(1).describe("Analysis request. Use @ syntax to include files (e.g., '@largefile.js explain what this does') or ask general questions"),
  backend: z.enum(['gemini', 'codex']).optional().describe("AI backend to use: 'gemini' (default) or 'codex'. Gemini offers 1M+ token context, Codex integrates with OpenAI models."),
  session: z.string().optional().describe("Session ID for conversation continuity (e.g., 'typescript-learning'). Maintains context across multiple questions."),
  model: z.string().optional().describe("Model override. Gemini: 'gemini-3-pro-preview' (default), 'gemini-2.5-pro'. Codex: 'gpt-5.2-codex' (default), 'gpt-5.1-codex-mini', 'gpt-5.2'"),
  reasoningEffort: z.enum(['low', 'medium', 'high', 'xhigh']).optional().describe("Reasoning effort level (Codex only): 'low', 'medium' (default), 'high', 'xhigh'. Use 'high'/'xhigh' for complex tasks."),
  sandbox: z.boolean().default(false).describe("Sandbox (Gemini) / workspace-write (Codex). For Codex: false => read-only (default), true => workspace-write. Ignored if sandboxMode is set."),
  sandboxMode: z.enum(['read-only', 'workspace-write', 'danger-full-access']).optional().describe("Codex-only override for sandbox policy (takes precedence over sandbox). Use 'danger-full-access' only with explicit opt-in."),
  changeMode: z.boolean().default(false).describe("Enable structured change mode - formats prompts to prevent tool errors and returns structured edit suggestions that Claude can apply directly"),
  includeHistory: z.boolean().default(true).describe("Include conversation history in context (only applies when session is provided). Default: true"),
  allowedTools: z.array(z.string()).optional().describe("Tools that the AI can auto-approve without confirmation (e.g., ['run_shell_command'] for git commands). Use sparingly for security."),
  cwd: z.string().optional().describe("Working directory for CLI execution. Use this to match your IDE workspace directory if you get 'Directory mismatch' errors."),
});

export const askTool: UnifiedTool = {
  name: "ask",
  description: "Query AI with file analysis, session continuity, and dual-backend support (Gemini/Codex). Use backend:'codex' for OpenAI, defaults to Gemini.",
  zodSchema: askArgsSchema,
  prompt: {
    description: "Execute AI query with optional file references, session management, and backend selection.",
  },
  category: 'ai',
  execute: async (args, onProgress) => {
    const {
      prompt,
      backend: backendChoice,
      session,
      model,
      reasoningEffort,
      sandbox,
      sandboxMode,
      changeMode,
      includeHistory,
      allowedTools,
      cwd
    } = args;

    if (!prompt?.trim()) {
      throw new Error(ERROR_MESSAGES.NO_PROMPT_PROVIDED);
    }

    // Session handling - load first so we can use lastBackend for backend selection
    let sessionData: Awaited<ReturnType<typeof askSessionManager.getOrCreate>> | null = null;
    let enhancedPrompt = prompt as string;

    if (session) {
      try {
        sessionData = await askSessionManager.getOrCreate(session as string);

        // Build conversation context if history is enabled
        if (includeHistory && sessionData.conversationHistory.length > 0) {
          const historyContext = askSessionManager.buildConversationContext(sessionData, 3);
          enhancedPrompt = `${historyContext}\n\n# Current Question\n${prompt}`;
        }

        onProgress?.(`üìù Session '${session}' (Round ${sessionData.totalRounds + 1})`);
      } catch (error) {
        onProgress?.(`‚ö†Ô∏è  Session loading failed: ${error instanceof Error ? error.message : String(error)}`);
        Logger.error(`Failed to load session '${session}': ${error}`);
        // Continue without session
      }
    }

    // Get the appropriate backend (defaults to session's last backend, then Gemini)
    const backendType: BackendType = backendChoice || sessionData?.lastBackend || 'gemini';
    const backend = await getBackend(backendType);

    onProgress?.(`ü§ñ Using ${backend.name} backend...`);

    // Execute via the selected backend
    // Pass existing codexThreadId for native session resume when using Codex
    const result = await backend.execute(
      enhancedPrompt,
      {
        provider: backendType,
        model: model as string | undefined,
        sandbox: !!sandbox,
        sandboxMode: sandboxMode as 'read-only' | 'workspace-write' | 'danger-full-access' | undefined,
        changeMode: !!changeMode,
        allowedTools: allowedTools as string[] | undefined,
        cwd: cwd as string | undefined,
        codexThreadId: sessionData?.codexThreadId, // For Codex native session resume
        reasoningEffort: reasoningEffort as 'low' | 'medium' | 'high' | 'xhigh' | undefined,
      },
      onProgress
    );

    // Save to session if provided
    if (session && sessionData) {
      try {
        const contextFiles = extractFilesFromPrompt(prompt as string);
        // Use model from backend result (actual model used), fallback to input or default
        const usedModel =
          result.model ||
          (model as string) ||
          (backendType === 'codex' ? CODEX_MODELS.DEFAULT : MODELS.PRO_3);
        askSessionManager.addRound(
          sessionData,
          prompt as string,
          result.response,
          usedModel,
          contextFiles,
          backendType,
          result.codexThreadId // Store Codex thread ID for native session resume
        );
        await askSessionManager.save(sessionData);
        onProgress?.(`üíæ Saved to session '${session}' (${sessionData.totalRounds} rounds)`);
        if (result.codexThreadId && result.codexThreadId.length > 0) {
          const threadPreview = result.codexThreadId.slice(0, 8);
          onProgress?.(`üîó Codex thread: ${threadPreview}...`);
        }
      } catch (error) {
        onProgress?.(`‚ö†Ô∏è  Session save failed: ${error instanceof Error ? error.message : String(error)}`);
        Logger.error(`Failed to save session '${session}': ${error}`);
        // Continue - result is still valid even if session save failed
      }
    }

    if (changeMode) {
      return processChangeModeOutput(result.response);
    }

    // Use backend-aware response prefix
    const backendName = backend.name.charAt(0).toUpperCase() + backend.name.slice(1);
    return `${backendName} response:\n${result.response}`;
  }
};

// Backward compatibility: register as a separate tool name
export const askGeminiTool: UnifiedTool = {
  ...askTool,
  name: 'ask-gemini',
  description: "Backward-compatible alias for 'ask'.",
};
